import {createFilter} from 'rollup-pluginutils';
import parse5 from 'parse5';
import dom5 from 'dom5';
import path from 'path';

/**
 * Map of files which have been generated by the build step.
 * HTML files are broken apart into chunks of either HTML fragments or inline
 * scripts, which are then imported using generated paths. This maps from the
 * generated path to the content of the script.
 */
const extractedCode = new Map();
/**
 * Set of HTML file paths which have been processed.
 */
const inlinedHtmlFiles = new Set();

/**
 * Generate a JS import statement which is the equivalent to the link tag.
 */
function importLink(imports, node) {
  const href = dom5.getAttribute(node, 'href');
  const line = `import {} from './${href}';`;
  imports.push(line);
}

/**
 * Generate a JS import statement to include the inlined script contents.
 */
function importInlineScript(imports, node, scriptIndex, htmlPath) {
  const dirname = path.dirname(htmlPath);
  const basename = path.basename(htmlPath);

  const scriptName = `${basename}.${scriptIndex}.js`;
  const scriptPath = path.resolve(dirname, scriptName);

  const prefix = `// Generated from ${htmlPath}.\n`
  const scriptContents = prefix + dom5.getTextContent(node);

  // Store the actual script contents in extracted code for later inclusion.
  extractedCode.set(scriptPath, scriptContents);

  const line = `import {} from './${scriptName}';`;
  imports.push(line)
}

/**
 * Generate a JS import statement for the nodes.
 * The nodes are accessed via an import so ordering can be maintained between
 * link and inline script references.

 * @param {!Array<string>} imports
 * @param {!Array<parse5.Node>} accumulated
 * @param {number} fragmentIndex
 * @param {string} htmlPath
 */
function importAccumulatedNodes(imports, accumulated, fragmentIndex, htmlPath) {
  const fragment = dom5.constructors.fragment();
  for (const node of accumulated) {
    dom5.append(fragment, dom5.cloneNode(node));
  }

  // Clear out what has been written
  accumulated.length = 0;

  const comments = dom5.nodeWalkAll(fragment, dom5.isCommentNode);
  for (const comment of comments) {
    dom5.remove(comment);
  }

  let html = parse5.serialize(fragment);
  html = html.replace(/\\/g, '\\\\');
  html = html.replace(/\`/g, '\\`');
  html = html.trim();

  if (!html) return;

  const dirname = path.dirname(htmlPath);
  const basename = path.basename(htmlPath);
  const fragmentName = `${basename}.${fragmentIndex}.html.js`;
  const fragmentPath = path.resolve(dirname, fragmentName);

  const line = `import {} from './${fragmentName}';`;
  imports.push(line);

  const fragmentScript = `
    {
      // Generated from ${htmlPath}.
      const html = \`${html}\`;

      const range = document.createRange();
      const fragment = range.createContextualFragment(html);

      const link = document.createElement('link');
      link.appendChild(fragment);
      document.head.appendChild(link);
    }`;

  extractedCode.set(fragmentPath, fragmentScript);
}

function transformHtmlToJs(htmlDocument, htmlPath) {
  inlinedHtmlFiles.add(htmlPath);

  const ast = parse5.parseFragment(htmlDocument);
  const dirname = path.dirname(htmlPath);
  const basename = path.basename(htmlPath);

  const imports = [];
  let scriptIndex = 0;
  let fragmentIndex = 0;

  // Order of imports is important, scripts and links may need to be
  // interleave with HTML content.
  let accumulatedNodes = [];
  for (const node of ast.childNodes) {
    if (isHtmlImportNode(node)) {
      importAccumulatedNodes(imports, accumulatedNodes, fragmentIndex++, htmlPath);
      importLink(imports, node);
    } else if (isInlineScriptNode(node)) {
      importAccumulatedNodes(imports, accumulatedNodes, fragmentIndex++, htmlPath);
      importInlineScript(imports, node, scriptIndex++, htmlPath);
    } else {
      accumulatedNodes.push(node);
    }
  }
  importAccumulatedNodes(imports, accumulatedNodes, fragmentIndex++, htmlPath);

  const jsDocument = imports.join('\n');

  return {code: jsDocument, map: { mappings: '' }};
}

const isHtmlImportNode = dom5.predicates.AND(
  dom5.predicates.hasTagName('link'),
  dom5.predicates.hasAttrValue('rel', 'import'),
  dom5.predicates.NOT(dom5.predicates.hasAttrValue('type', 'css'))
);

const isInlineScriptNode = dom5.predicates.AND(
  dom5.predicates.hasTagName('script'),
  dom5.predicates.NOT(dom5.predicates.hasAttr('src'))
);

const isImportNode = dom5.predicates.OR(
  isHtmlImportNode,
  isInlineScriptNode
);

export default function htmlImport(options = {}) {
  const filter = createFilter(options.include || ['**/*.html'], options.exclude);

  return {
    name: 'html-import',

    load(id) {
      const scriptContents = extractedCode.get(id);
      return scriptContents;
    },

    resolveId(importee, importer) {
      // If the importer is not one of the generated files, ignore.
      if (!inlinedHtmlFiles.has(importer)) return null;

      const dirname = path.dirname(importer);
      const scriptPath = path.resolve(path.dirname(importer), importee);

      if (extractedCode.has(scriptPath)) {
        return scriptPath;
      }
      return null;
    },

    transform(code, id) {
      if (filter(id)) {
        return transformHtmlToJs(code, id);
      }
    }
  };
}
